/*
Copyright (c) 2013, Pierre KRIEGER
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.
    * Neither the name of the <organization> nor the
      names of its contributors may be used to endorse or promote products
      derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef INCLUDE_LUACONTEXT_HPP
#define INCLUDE_LUACONTEXT_HPP

#include <algorithm>
#include <array>
#include <cassert>
#include <cmath>
#include <cstring>
#include <functional>
#include <limits>
#include <list>
#include <map>
#include <memory>
#include <random>
#include <set>
#include <stdexcept>
#include <string>
#include <sstream>
#include <tuple>
#include <type_traits>
#include <unordered_map>
#include <boost/any.hpp>
#include <boost/mpl/distance.hpp>
#include <boost/optional.hpp>
#include <boost/variant.hpp>
#include <lua.hpp>

#ifdef _MSC_VER
#	include "exception.hpp"
#endif

#if defined(__GNUC__) && __GNUC__ <= 4 && __GNUC_MINOR__ <= 7
namespace std {
	template<typename T>
	using is_trivially_destructible = has_trivial_destructor<T>;
}
#endif

/**
 * Defines a Lua context
 * A Lua context is used to interpret Lua code. Since everything in Lua is a variable (including functions),
 * we only provide few functions like readVariable and writeVariable.
 *
 * You can also write variables with C++ functions so that they are callable by Lua. Note however that you HAVE TO convert
 * your function to std::function (not directly std::bind or a lambda function) so the class can detect which argument types
 * it wants. These arguments may only be of basic types (int, float, etc.) or std::string.
 */
class LuaContext {
public:
	explicit LuaContext(bool openDefaultLibs = true)
	{
		// luaL_newstate can return null if allocation failed
		mState = luaL_newstate();
		if (mState == nullptr)		throw std::bad_alloc();

		// setting the panic function
		lua_atpanic(mState, [](lua_State* state) -> int {
			const std::string str = lua_tostring(state, -1);
			lua_pop(state, 1);
			assert(false);
			exit(0);
		});

		// opening default library if required to do so
		if (openDefaultLibs)
			luaL_openlibs(mState);
	}

	//LuaContext(LuaContext&& s) : mState(s.mState) { s.mState = nullptr; }					// TODO: handle problem with "this" pointer being stored in lua
	//LuaContext& operator=(LuaContext&& s) { std::swap(mState, s.mState); return *this; }		// TODO: handle problem with "this" pointer being stored in lua

	~LuaContext()
	{
		if (mState != nullptr)
			lua_close(mState);
	}
	
	/// \brief Thrown when an error happens during execution of lua code (like not enough parameters for a function)
	class ExecutionErrorException : public std::runtime_error { public: ExecutionErrorException(const std::string& msg) : std::runtime_error(msg.c_str()) {} };
	/// \brief Thrown when a syntax error happens in a lua script
	class SyntaxErrorException : public std::runtime_error { public: SyntaxErrorException(const std::string& msg) : std::runtime_error(msg.c_str()) {} };
	/// \brief Generated by readVariable, isVariableArray, etc. when the asked variable doesn't exist/is nil
	class VariableDoesntExistException : public std::runtime_error { public: VariableDoesntExistException(const std::string& variable) : std::runtime_error("Trying to access a Lua variable which doesn't exist") {} };

	/**
	 * Thrown when trying to cast a lua variable to an unvalid type, eg. trying to read a number when the variable is a string
	 */
	class WrongTypeException : public std::runtime_error
	{
	public:
		WrongTypeException(std::string luaType, const std::type_info& destination) :
			std::runtime_error("Trying to cast a lua variable from \"" + luaType + "\" to \"" + destination.name() + "\""),
			luaType(luaType),
			destination(destination)
		{
		};
		
		std::string luaType;
		const std::type_info& destination;
	};
	
	/// \brief Executes lua code from the stream
	/// \param code A stream that lua will read its code from
	void		executeCode(std::istream& code)						{ load(code); call<std::tuple<>>(std::tuple<>()); }
	/// \brief Executes lua code from the stream and returns a value
	/// \param code A stream that lua will read its code from
	template<typename T>
	T			executeCode(std::istream& code)						{ load(code); return call<T>(std::tuple<>()); }
	/// \brief Executes lua code given as parameter
	/// \param code A string containing code that will be executed by lua
	void		executeCode(const std::string& code)				{ executeCode(code.c_str()); }
	/// \brief Executes lua code given as parameter and returns a value
	/// \param code A string containing code that will be executed by lua
	template<typename T>
	T			executeCode(const std::string& code)				{ return executeCode<T>(code.c_str()); }
	/// \brief Executes lua code given as parameter
	/// \param code A string containing code that will be executed by lua
	void		executeCode(const char* code)						{ load(code); call<std::tuple<>>(std::tuple<>()); }
	/// \brief Executes lua code given as parameter and returns a value
	/// \param code A string containing code that will be executed by lua
	template<typename T>
	T			executeCode(const char* code)						{ load(code); return call<T>(std::tuple<>()); }
	

	/// \brief Tells that lua will be allowed to access an object's function
	template<typename TType, typename TRetValue, typename... TArgs>
	void 				registerFunction(const std::string& name, TRetValue (TType::*f)(TArgs...))			{ registerFunctionImpl(name, std::function<TRetValue (TType*, TArgs...)>([=](TType* obj, TArgs&&... params) { return (obj->*f)(std::forward<TArgs>(params)...); })); }

	/// \brief Adds a custom function to a type determined using the function's first parameter
	/// \param fn Function which takes as first parameter a std::shared_ptr
	template<typename TFunctionType, typename TType>
	void				registerFunction(const std::string& name, TType fn)								{ static_assert(std::is_function<TFunctionType>::value, "registerFunction must take a function type as template parameter"); registerFunctionImpl(name, std::function<TFunctionType>(fn)); }

	/// \brief Inverse operation of registerFunction
	template<typename T>
	void				unregisterFunction(const std::string& name)										{ throw std::logic_error("Not yet implemented"); }

	/**
	 * Registers a member variable
	 */
	template<typename TObject, typename TVarType>
	void 				registerMember(const std::string& name, TVarType TObject::*member)				{ registerMember<TObject>(name, [=](const TObject& obj) -> TVarType { return obj.*member; }, [=](TObject& obj, const TVarType& value) { obj.*member = value; }); }

	/**
	 * Registers a member variable
	 * @param readFunction		Function that takes as parameter a const TObject& and returns the value of the member variable
	 * @param writeFunction		Function that takes as parameter a TObject& and a const TVarType&, and modifies the object
	 */
	template<typename TObject, typename TVarType>
	void 				registerMember(const std::string& name, std::function<TVarType (const TObject&)> readFunction, std::function<void (TObject&, const TVarType&)> writeFunction)			{ registerMemberImpl<TObject,TVarType>(name, std::move(readFunction), std::move(writeFunction)); }

	/**
	 * Registers a dynamic member variable
	 */
	template<typename TObject, typename TVarType>
	void 				registerMember(std::function<TVarType (const TObject&, const std::string&)> readFunction, std::function<void (TObject&, const std::string&, const TVarType&)> writeFunction)			{ registerMemberImpl<TObject,TVarType>(std::move(readFunction), std::move(writeFunction)); }

	/// \brief Calls a function stored in a lua variable
	/// \details Template parameter of the function should be the expected return type (tuples and void are supported)
	/// \param variableName Name of the variable containing the function to call
	/// \param ... Parameters to pass to the function
	/// \note Equivalent to readVariable<std::function<RetValueType (ParamsType...)>>(variableName)(params...);
	/*template<typename R, typename... Args>
	R callLuaFunction(const std::string& variableName, const Args&... args) {
		_getGlobal(variableName);
		return _call<R>(std::make_tuple(args...));
	}*/
	

	/**
	 * Returns true if the value of the variable is an array
	 * @param variableName Name of the variable to check
	 */
	bool isVariableArray(const std::string& variableName) const
	{
		getGlobal(variableName);
		bool answer = lua_istable(mState, -1);
		lua_pop(mState, 1);
		return answer;
	}

	/**
	 * @sa isVariableArray
	 */
	bool isVariableArray(const char* variableName) const
	{
		return isVariableArray(std::string{variableName});
	}
	
	/// \brief Returns true if variable exists (ie. not nil)
	bool				hasVariable(const std::string& variableName) const					{ getGlobal(variableName); bool answer = lua_isnil(mState, -1); lua_pop(mState, 1); return !answer; }

	/// \brief Destroys a variable
	/// \details Puts the nil value into it
	/// \note Equivalent to writeVariable(variableName, nullptr)
	void				clearVariable(const std::string& variableName)						{ lua_pushnil(mState); setGlobal(variableName); }
	void				clearVariable(const char* variableName)								{ lua_pushnil(mState); setGlobal(variableName); }
	
	/** \brief Returns the content of a variable
		\throw VariableDoesntExistException When the variable doesn't exist
		\throw WrongTypeException When the variable is not convertible to the requested type
		\sa writeVariable
		\details Readable types are:
					* all types accepted by writeVariable except nullptr
					* std::tuple<> where all members are accepted values

				After the variable name, you can add other parameters.
				If the variable is an array, it will instead get the element of that array whose offset is the second parameter.
				Same applies for third, fourth, etc. parameters.
	*/
	template<typename T>
	T					readVariable(const std::string& variableName) const											{ getGlobal(variableName); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1>
	T					readVariable(const std::string& variableName, O1 o1) const									{ getGlobal(variableName); lookIntoStackTop(o1); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2>
	T					readVariable(const std::string& variableName, O1 o1, O2 o2) const							{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2, typename O3>
	T					readVariable(const std::string& variableName, O1 o1, O2 o2, O3 o3) const					{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); lookIntoStackTop(o3); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2, typename O3, typename O4>
	T					readVariable(const std::string& variableName, O1 o1, O2 o2, O3 o3, O4 o4) const				{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); lookIntoStackTop(o3); lookIntoStackTop(o4); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2, typename O3, typename O4, typename O5>
	T					readVariable(const std::string& variableName, O1 o1, O2 o2, O3 o3, O4 o4, O5 o5) const		{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); lookIntoStackTop(o3); lookIntoStackTop(o4); lookIntoStackTop(o5); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T>
	T					readVariable(const char* variableName) const												{ getGlobal(variableName); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1>
	T					readVariable(const char* variableName, O1 o1) const											{ getGlobal(variableName); lookIntoStackTop(o1); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2>
	T					readVariable(const char* variableName, O1 o1, O2 o2) const									{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2, typename O3>
	T					readVariable(const char* variableName, O1 o1, O2 o2, O3 o3) const							{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); lookIntoStackTop(o3); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2, typename O3, typename O4>
	T					readVariable(const char* variableName, O1 o1, O2 o2, O3 o3, O4 o4) const					{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); lookIntoStackTop(o3); lookIntoStackTop(o4); T out; readTopAndPop(1, &out); return std::move(out); }
	template<typename T, typename O1, typename O2, typename O3, typename O4, typename O5>
	T					readVariable(const char* variableName, O1 o1, O2 o2, O3 o3, O4 o4, O5 o5) const				{ getGlobal(variableName); lookIntoStackTop(o1); lookIntoStackTop(o2); lookIntoStackTop(o3); lookIntoStackTop(o4); lookIntoStackTop(o5); T out; readTopAndPop(1, &out); return std::move(out); }
	
	/** \brief Changes the content of a global lua variable
		\details Accepted values are:
					* all base types (char, short, int, float, double, bool)
					* std::string
					* "Any" (defined above)
					* "Table" (defined above)
					* std::map<> and std::unordered_map<> (the key and value must also be accepted values)
					* std::function<> (all parameters must be accepted values, and return type must be an accepted value for readVariable)
					* std::shared_ptr<> (std::unique_ptr<> are converted to std::shared_ptr<>)
					* std::vector<std::pair<boost::any,boost::any>> for a table
					* nullptr (writes nil)
				All objects are passed by copy and destroyed by the garbage collector if necessary.
	*/
	template<typename T>
	void writeVariable(const std::string& variableName, T&& data) {
		static_assert(!std::is_same<typename Tupleizer<T>::type,T>::value, "Error: you can't use LuaContext::writeVariable with a tuple");
		const int pushedElems = Pusher<typename std::decay<T>::type>::push(*this, std::forward<T>(data));
		try { setGlobal(variableName); } catch(...) { lua_pop(mState, pushedElems); throw; }
		if (pushedElems >= 2) lua_pop(mState, pushedElems - 1);
	}

	/// \brief
	template<typename FunctionType, typename FunctionObject>
	void writeFunction(const std::string& variableName, const FunctionObject& functionObject) {
		
	}



private:
	// forbidding copy
	LuaContext(const LuaContext&);
	LuaContext& operator=(const LuaContext&);


	// the state is the most important variable in the class since it is our interface with Lua
	// the mutex is here because the lua design is not thread safe (based on a stack)
	//   eg. if multiple thread call "writeVariable" at the same time, we don't want them to be executed simultaneously
	// the mutex should be locked by all public functions that use the stack
	lua_State*					mState;

	// these variables store the list of getters and setters registered for a custom type
	// for example if you write a shared_ptr<Foo> to a variable named "a", and a script is executed with "a.something", then "something" will be looked for in one of these tables
	// the function will push the return value 
	std::unordered_map<const std::type_info*,std::unordered_map<std::string,std::function<int (const void*, LuaContext&)>>>		mRegisteredGetters;
	std::unordered_map<const std::type_info*,std::function<int (const void*, const std::string&, LuaContext&)>>					mDefaultGetter;
	std::unordered_map<const std::type_info*,std::unordered_map<std::string, std::function<void (void*, LuaContext&)>>>			mRegisteredSetters;
	std::unordered_map<const std::type_info*,std::function<void (void*, const std::string&, LuaContext&)>>						mDefaultSetter;
	
	// all the user types in the mState must have the value of &typeid(T) in their
	//   metatable at key "_typeid"

	// dummy functions
	void	getGlobal(const std::string& variable) const			{ getGlobal(variable.c_str()); }
	void	getGlobal(const char* variable) const					{ lua_getglobal(mState, variable); }
	void	setGlobal(const std::string& variable)					{ setGlobal(variable.c_str()); }
	void	setGlobal(const char* variable)							{ lua_setglobal(mState, variable); }

	// this function takes a value representing the offset to look into
	template<typename OffsetType>
	void lookIntoStackTop(OffsetType offset) const {
		const int pushed = push(offset);
		if (pushed >= 2)
			lua_pop(mState, pushed - 1);
		lua_gettable(mState, -2);
		lua_remove(mState, -2);
	}
	void lookIntoStackTop(void* p) const {
		assert(!p);
	}
	void lookIntoStackTop(std::nullptr_t) const {
	}

	// simple function that reads the top N elements of the stack, pops them, and writes them to "ptr"
	// warning: first parameter is the number of parameters, not the parameter index
	// if read generates an exception, stack is poped anyway
	template<typename R>
	auto readTopAndPop(int nb, R* ptr) const
		-> typename std::enable_if<!std::is_void<R>::value>::type
	{
		auto val = Reader<typename std::decay<R>::type>::testRead(*this, -nb);
		if (val.is_initialized())
			*ptr = std::move(val.get());
		lua_pop(mState, nb);
		if (!val.is_initialized())
			throw WrongTypeException{lua_typename(mState, lua_type(mState, -nb)), typeid(R)};
	}
	void readTopAndPop(int nb, void* ptr) const {
		lua_pop(mState, nb);
	}
	

	/**************************************************/
	/*            FUNCTIONS REGISTRATION              */
	/**************************************************/
	// the "registerFunction" public functions call this one
	template<typename TRetValue, typename TParam1, typename... TOtherParams>
	void registerFunctionImpl(const std::string& functionName, std::function<TRetValue (TParam1, TOtherParams...)> function)
	{
		static_assert(std::is_class<TParam1>::value || std::is_pointer<TParam1>::value, "registerFunction can only be called on a class or a pointer");

		mRegisteredGetters[&typeid(std::decay<TParam1>::type)][functionName] =
			[=](const void*, LuaContext& ctxt) -> int {
				return ctxt.pushFunction<TRetValue (TParam1, TOtherParams...)>(function);
			};

		mRegisteredGetters[&typeid(typename std::decay<TParam1>::type*)][functionName] =
			[=](const void*, LuaContext& ctxt) -> int {
				return ctxt.pushFunction<TRetValue (typename std::decay<TParam1>::type*, TOtherParams...)>([=](typename std::decay<TParam1>::type* obj, TOtherParams... rest) { return function(*obj, std::forward<TOtherParams>(rest)...); });
			};

		mRegisteredGetters[&typeid(std::shared_ptr<typename std::decay<TParam1>::type>)][functionName] =
			[=](const void*, LuaContext& ctxt) -> int {
				return ctxt.pushFunction<TRetValue (std::shared_ptr<typename std::decay<TParam1>::type>, TOtherParams...)>([=](std::shared_ptr<typename std::decay<TParam1>::type> obj, TOtherParams... rest) { return function(*obj, std::forward<TOtherParams>(rest)...); });
			};
	}

	// the "registerMember" public functions call this one
	template<typename TObject, typename TVarType>
	void registerMemberImpl(const std::string& name, std::function<TVarType (const TObject&)> readFunction, std::function<void (TObject&, const TVarType&)> writeFunction)
	{
		static_assert(std::is_class<TObject>::value, "registerMember can only be called on a class");

		if (readFunction) {
			mRegisteredGetters[&typeid(TObject)][name] = [=](const void* object, LuaContext& ctxt) -> int {
				return Pusher<typename std::decay<TVarType>::type>::push(ctxt, readFunction(*static_cast<const TObject*>(object)));
			};
		}

		if (writeFunction) {
			mRegisteredSetters[&typeid(TObject)][name] = [=](void* object, LuaContext& ctxt) {
				writeFunction(*static_cast<TObject*>(object), Reader<typename std::decay<TVarType>::type>::readSafe(*this, -1));
			};
		}
	}

	// the "registerMember" public functions call this one
	template<typename TObject, typename TVarType>
	void registerMemberImpl(std::function<TVarType (const TObject&, const std::string&)> readFunction, std::function<void (TObject&, const std::string&, const TVarType&)> writeFunction)
	{
		if (readFunction) {
			mDefaultGetter[&typeid(TObject)] = [=](const void* object, const std::string& name, LuaContext& ctxt) -> int {
				return Pusher<typename std::decay<TVarType>::type>::push(ctxt, readFunction(*static_cast<const TObject*>(object), name));
			};
		}

		if (writeFunction) {
			mDefaultSetter[&typeid(TObject)] = [=](void* object, const std::string& name, LuaContext& ctxt) {
				writeFunction(*static_cast<TObject*>(object), name, Reader<typename std::decay<TVarType>::type>::readSafe(*this, -1));
			};
		}
	}
	

	/**************************************************/
	/*              LOADING AND CALLING               */
	/**************************************************/
	// this function loads data from the stream and pushes a function at the top of the stack
	// throws in case of syntax error
	void load(std::istream& code) {
		// since the lua_load function requires a static function, we use this structure
		// the Reader structure is at the same time an object storing an istream and a buffer,
		//   and a static function provider
		struct Reader {
			Reader(std::istream& str) : stream(str) {}
			std::istream&			stream;
			std::array<char,512>	buffer;

			// read function ; "data" must be an instance of Reader
			static const char* read(lua_State* l, void* data, size_t* size) {
				assert(size != nullptr);
				assert(data != nullptr);
				Reader& me = *static_cast<Reader*>(data);
				if (me.stream.eof())	{ *size = 0; return nullptr; }

				me.stream.read(me.buffer.data(), me.buffer.size());
				*size = static_cast<size_t>(me.stream.gcount());	// gcount could return a value larger than a size_t, but its maximum is sizeof(me.buffer) so there's no problem
				return me.buffer.data();
			}
		};

		// we create an instance of Reader, and we call lua_load
		Reader reader{code};
		auto loadReturnValue = lua_load(mState, &Reader::read, &reader, "chunk"
#			if LUA_VERSION_NUM >= 502
				, nullptr
#			endif
		);

		// now we have to check return value
		if (loadReturnValue != 0) {
			// there was an error during loading, an error message was pushed on the stack
			const std::string errorMsg = lua_tostring(mState, -1);
			lua_pop(mState, 1);
			if (loadReturnValue == LUA_ERRMEM)				throw std::bad_alloc();
			else if (loadReturnValue == LUA_ERRSYNTAX)		throw SyntaxErrorException{errorMsg};
		}
	}

	void load(const char* code) {
		auto loadReturnValue = luaL_loadstring(mState, code);

		// now we have to check return value
		if (loadReturnValue != 0) {
			// there was an error during loading, an error message was pushed on the stack
			const std::string errorMsg = lua_tostring(mState, -1);
			lua_pop(mState, 1);
			if (loadReturnValue == LUA_ERRMEM)				throw std::bad_alloc();
			else if (loadReturnValue == LUA_ERRSYNTAX)		throw SyntaxErrorException{errorMsg};
		}
	}

	// this function calls what is on the top of the stack and removes it (just like lua_call)
	// if an exception is triggered, the top of the stack will be removed anyway
	// In should be a tuple (at least until variadic templates are supported everywhere), Out can be anything
	template<typename Out, typename In>
	Out call(const In& in) const {
		static_assert(std::tuple_size<In>::value >= 0, "Error: template parameter 'In' should be a tuple");

		int outArguments = 0;
		int inArguments = 0;
		try {
			// we push the parameters on the stack
			outArguments = std::tuple_size<typename Tupleizer<Out>::type>::value;
			inArguments = Pusher<In>::push(*this, in);
		} catch(...) { lua_pop(mState, 1); throw; }

		// calling pcall automatically pops the parameters and pushes output
		const auto pcallReturnValue = lua_pcall(mState, inArguments, outArguments, 0);

		// if pcall failed, analyzing the problem and throwing
		if (pcallReturnValue != 0) {
			// an error occured during execution, either an error message or a std::exception_ptr was pushed on the stack
			if (pcallReturnValue == LUA_ERRMEM) {
				throw std::bad_alloc();

			} else if (pcallReturnValue == LUA_ERRRUN) {
				if (lua_isstring(mState, 1)) {
					// the error is a string
					std::string errorMsg;
					readTopAndPop(1, &errorMsg);
					throw ExecutionErrorException(errorMsg);

				} else {
					// an exception_ptr was pushed on the stack
					// rethrowing it with an additional ExecutionErrorException
					std::exception_ptr exception;
					readTopAndPop(1, &exception);
					try {
						std::rethrow_exception(exception);
					} catch(...) {
						std::throw_with_nested(ExecutionErrorException("Exception thrown by a callback function called by Lua"));
					}
				}
			}
		}

		// pcall succeeded, we pop the returned values and return them
		try {
			Out out;
			readTopAndPop(outArguments, &out);
			return std::move(out);

		} catch(...) {
			lua_pop(mState, outArguments);
			throw;
		}
	}

	
	/**************************************************/
	/*                PUSH FUNCTIONS                  */
	/**************************************************/
	// any object
	template<typename TType, typename = void>
	struct Pusher {
		template<typename TType2>
		static int push(const LuaContext& context, TType2&& value) {
			// this function is called when lua's garbage collector wants to destroy our object
			// we simply call its destructor
			const auto garbageCallbackFunction = [](lua_State* lua) -> int {
				assert(lua_gettop(lua) == 1);
				TType* ptr = static_cast<TType*>(lua_touserdata(lua, 1));
				assert(ptr);
				ptr->~TType();
				return 0;
			};

			// this function will be stored in __index in the metatable
			const auto indexFunction = [](lua_State* lua) -> int {
				assert(lua_gettop(lua) == 2);
				assert(lua_isuserdata(lua, 1));
				assert(lua_isstring(lua, 2));

				const auto me = static_cast<LuaContext*>(lua_touserdata(lua, lua_upvalueindex(1)));
				const auto memberName = lua_tostring(lua, 2);

				// looking for a function in getters list
				try {
					const auto iter1 = me->mRegisteredGetters.find(&typeid(TType));
					if (iter1 != me->mRegisteredGetters.end()) {
						const auto iter2 = iter1->second.find(memberName);
						if (iter2 != iter1->second.end()) {
							const auto& function = iter2->second;
							return function(lua_touserdata(lua, 1), *me);
						}
					}

					return me->mDefaultGetter.at(&typeid(TType))(lua_touserdata(lua, 1), memberName, *me);

				} catch (...) {
					Pusher<std::exception_ptr>::push(*me, std::current_exception());
					lua_error(lua);
					throw "Dummy exception";
				}
			};

			// this function will be stored in __newindex in the metatable
			const auto newIndexFunction = [](lua_State* lua) -> int {
				assert(lua_gettop(lua) == 3);
				assert(lua_isuserdata(lua, 1));
				assert(lua_isstring(lua, 2));

				const auto me = static_cast<LuaContext*>(lua_touserdata(lua, lua_upvalueindex(1)));
				const auto memberName = lua_tostring(lua, 2);

				// looking for a function in getters list
				try {
					const auto iter1 = me->mRegisteredSetters.find(&typeid(TType));
					if (iter1 != me->mRegisteredSetters.end()) {
						const auto iter2 = iter1->second.find(memberName);
						if (iter2 != iter1->second.end()) {
							const auto& function = iter2->second;
							function(lua_touserdata(lua, 1), *me);
							return 0;
						}
					}

					me->mDefaultSetter.at(&typeid(TType))(lua_touserdata(lua, 1), memberName, *me);
					return 0;
				
				} catch (...) {
					Pusher<std::exception_ptr>::push(*me, std::current_exception());
					lua_error(lua);
					throw "Dummy exception";
				}
			};

			// creating the object
			// lua_newuserdata allocates memory in the internals of the lua library and returns it so we can fill it
			//   and that's what we do with placement-new
			const auto pointerLocation = static_cast<TType*>(lua_newuserdata(context.mState, sizeof(TType)));
			new (pointerLocation) TType(std::forward<TType2>(value));

			try {
				// creating the metatable (over the object on the stack)
				// lua_settable pops the key and value we just pushed, so stack management is easy
				// all that remains on the stack after these function calls is the metatable
				lua_newtable(context.mState);
				try {
					// using the garbage collecting function we created above
					if (!std::is_trivially_destructible<TType>::value)
					{
						lua_pushstring(context.mState, "__gc");
						lua_pushcfunction(context.mState, garbageCallbackFunction);
						lua_settable(context.mState, -3);
					}

					// settings typeid of shared_ptr this time
					lua_pushstring(context.mState, "_typeid");
					lua_pushlightuserdata(context.mState, const_cast<std::type_info*>(&typeid(TType)));
					lua_settable(context.mState, -3);

					// using the index function we created above
					lua_pushstring(context.mState, "__index");
					lua_pushlightuserdata(context.mState, const_cast<void*>(static_cast<const void*>(&context)));
					lua_pushcclosure(context.mState, indexFunction, 1);
					lua_settable(context.mState, -3);

					// using the newindex function we created above
					lua_pushstring(context.mState, "__newindex");
					lua_pushlightuserdata(context.mState, const_cast<void*>(static_cast<const void*>(&context)));
					lua_pushcclosure(context.mState, newIndexFunction, 1);
					lua_settable(context.mState, -3);

					// at this point, the stack contains the object at offset -2 and the metatable at offset -1
					// lua_setmetatable will bind the two together and pop the metatable
					// our custom type remains on the stack (and that's what we want since this is a push function)
					lua_setmetatable(context.mState, -2);

				}
				catch (...) { lua_pop(context.mState, 1); throw; }
			}
			catch (...) { lua_pop(context.mState, 1); throw; }

			return 1;
		}
	};

	
	/**************************************************/
	/*            CALL FUNCTION WITH TUPLE            */
	/**************************************************/
	template<int...>
	struct Sequence {};
	template<typename Sequence>
	struct IncrementSequence {};
	template<int N>
	struct GenerateSequence { typedef typename IncrementSequence<typename GenerateSequence<N - 1>::type>::type type; };

	template<typename TRetValue, typename TFunctionObject, typename TTuple, int... S>
	auto callWithTupleImpl(const TFunctionObject& function, const TTuple& parameters, Sequence<S...>) const
		-> TRetValue
	{
		return function(std::get<S>(parameters)...);
	}

	template<typename TRetValue, typename TFunctionObject, typename TTuple>
	auto callWithTuple(const TFunctionObject& function, const TTuple& parameters) const
		-> typename std::enable_if<!std::is_void<TRetValue>::value, std::tuple<TRetValue>>::type
	{
		return std::make_tuple(callWithTupleImpl<TRetValue>(function, parameters, typename GenerateSequence<std::tuple_size<TTuple>::value>::type()));
	}

	template<typename TRetValue, typename TFunctionObject, typename TTuple>
	auto callWithTuple(const TFunctionObject& function, const TTuple& parameters) const
		-> typename std::enable_if<std::is_void<TRetValue>::value,std::tuple<>>::type
	{
		callWithTupleImpl<TRetValue>(function, parameters, GenerateSequence<std::tuple_size<TTuple>::value>::type());
		return std::tuple<>();
	}


	
	/**************************************************/
	/*             PUSHING ANY FUNCTION               */
	/**************************************************/
	template<typename TFunctionType, typename TFunctionObject>
	int pushFunction(TFunctionObject fn) const {
		// when the lua script calls the thing we will push on the stack, we want "fn" to be executed
		// if we used lua's cfunctions system, we could not detect when the function is no longer in use, which could cause problems
		// so we use userdata instead

		typedef FunctionArgumentsGetter<TFunctionType>		FunctionArguments;
		
		// we will create a userdata which contains a copy of a lambda function [](lua_State*) -> int
		// but first we have to create it
		auto functionToPush = [&,fn](lua_State* state) -> int {			// TODO: problem if we move the lua context
			// note that I'm using "this->" because of a bug in g++
			assert(this->mState == state);
			
			// checking if number of parameters is correct
			const int paramsCount = std::tuple_size<typename FunctionArguments::Parameters>::value;
			if (lua_gettop(state) < paramsCount) {
				// if not, using lua_error to return an error
				luaL_where(state, 1);
				lua_pushstring(state, "This function requires at least ");
				lua_pushnumber(state, paramsCount);
				lua_pushstring(state, " parameter(s)");
				lua_concat(state, 4);

				// lua_error throws an exception when compiling as C++
				return lua_error(state);
			}
			
			// reading parameters from the stack
			auto parameters = Reader<typename std::decay<typename FunctionArguments::Parameters>::type>::readSafe(*this, -paramsCount);

			// calling the function, note that "result" should be a tuple
			auto result = callWithTuple<typename FunctionArguments::ReturnValue>(fn, parameters);

			// pushing the result on the stack and returning number of pushed elements
			return Pusher<typename std::decay<decltype(result)>::type>::push(*this, std::move(result));
		};
		
		// typedefing the type of data we will push
		typedef decltype(functionToPush)	FunctionPushType;
		
		// this function is called when the lua script tries to call our custom data type
		// what we do is we simply call the function
		const auto callCallback = [](lua_State* lua) -> int {
			assert(lua_gettop(lua) >= 1);
			assert(lua_isuserdata(lua, 1));
			FunctionPushType* function = static_cast<FunctionPushType*>(lua_touserdata(lua, 1));
			assert(function);
			return (*function)(lua);
		};

		// this one is called when lua's garbage collector no longer needs our custom data type
		// we call std::function<int (lua_State*)>'s destructor
		const auto garbageCallback = [](lua_State* lua) -> int {
			assert(lua_gettop(lua) == 1);
			FunctionPushType* function = static_cast<FunctionPushType*>(lua_touserdata(lua, 1));
			assert(function);
			function->~FunctionPushType();
			return 0;
		};

		// creating the object
		// lua_newuserdata allocates memory in the internals of the lua library and returns it so we can fill it
		//   and that's what we do with placement-new
		FunctionPushType* const functionLocation = static_cast<FunctionPushType*>(lua_newuserdata(mState, sizeof(FunctionPushType)));
		new (functionLocation) FunctionPushType(std::move(functionToPush));

		// creating the metatable (over the object on the stack)
		// lua_settable pops the key and value we just pushed, so stack management is easy
		// all that remains on the stack after these function calls is the metatable
		lua_newtable(mState);
		lua_pushstring(mState, "__call");
		lua_pushcfunction(mState, callCallback);
		lua_settable(mState, -3);
		lua_pushstring(mState, "_typeid");
		lua_pushlightuserdata(mState, const_cast<std::type_info*>(&typeid(decltype(fn))));
		lua_settable(mState, -3);
		lua_pushstring(mState, "__gc");
		lua_pushcfunction(mState, garbageCallback);
		lua_settable(mState, -3);

		// at this point, the stack contains the object at offset -2 and the metatable at offset -1
		// lua_setmetatable will bind the two together and pop the metatable
		// our custom function remains on the stack (and that's what we want)
		lua_setmetatable(mState, -2);

		return 1;
	}
	

	/**************************************************/
	/*                READ FUNCTIONS                  */
	/**************************************************/
	// - the "test" function will return true if the variable is of the right type
	// - the "read" function will assume that the variable is of the right type and read its value
	// - the "testRead" function will check and read at the same time, returning an empty optional if it is the wrong type
	// - the "readSafe" function does the same as "testRead" but throws in case of wrong type
	
	template<typename TType, typename = void>
	struct Reader {
		static bool test(const LuaContext& context, int index)
		{
			if (!lua_isuserdata(context.mState, index))
				return false;
			if (!lua_getmetatable(context.mState, index))
				return false;

			// now we have our metatable on the top of the stack
			// retrieving its _typeid member
			lua_pushstring(context.mState, "_typeid");
			lua_gettable(context.mState, -2);
			const auto storedTypeID = static_cast<const std::type_info*>(lua_touserdata(context.mState, -1));
			const auto typeIDToCompare = &typeid(TType);

			// if wrong typeid, returning false
			lua_pop(context.mState, 2);
			if (storedTypeID != typeIDToCompare)
				return false;

			return true;
		}

		static auto read(const LuaContext& context, int index)
			-> TType
		{
			return *static_cast<TType*>(lua_touserdata(context.mState, index));
		}

		static auto testRead(const LuaContext& context, int index)
			-> boost::optional<TType>
		{
			if (!test(context, index))
				return {};
			return read(context, index);
		}

		static auto readSafe(const LuaContext& context, int index)
			-> TType
		{
			if (!test(context, index))
				throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(TType)};
			return read(context, index);
		}
	};


	/**************************************************/
	/*                   UTILITIES                    */
	/**************************************************/
	template<typename T> struct Tupleizer;

	template<typename TFunctionType>
	struct FunctionArgumentsGetter {};
	template<typename TRetValue, typename... TParams>
	struct FunctionArgumentsGetter<TRetValue (TParams...)> {
		typedef std::tuple<TParams...>		Parameters;
		typedef TRetValue					ReturnValue;
	};
};

template<int... S>
struct LuaContext::IncrementSequence<LuaContext::Sequence<S...>> { typedef Sequence<S..., sizeof...(S)> type; };
template<>
struct LuaContext::GenerateSequence<0> { typedef Sequence<> type; };

// this structure takes a template parameter T
// if T is a tuple, it returns T ; if T is not a tuple, it returns std::tuple<T>
// we have to use this structure because std::tuple<std::tuple<...>> triggers a bug in both MSVC++ and GCC
template<typename T> struct LuaContext::Tupleizer						{ typedef std::tuple<T> type; };
/*template<typename... Args>
struct LuaContext::Tupleizer<std::tuple<Args...>>						{ typedef std::tuple<Args...> type; };*/
template<> struct LuaContext::Tupleizer<void>							{ typedef std::tuple<> type; };	




/**************************************************/
/*                PUSH FUNCTIONS                  */
/**************************************************/
// boolean
template<>
struct LuaContext::Pusher<bool> {
	static int push(const LuaContext& context, bool value) {
		lua_pushboolean(context.mState, value);
		return 1;
	}
};

// string
template<>
struct LuaContext::Pusher<std::string> {
	static int push(const LuaContext& context, const std::string& value) {
		lua_pushstring(context.mState, value.c_str());
		return 1;
	}
};

// const char*
template<>
struct LuaContext::Pusher<const char*> {
	static int push(const LuaContext& context, const char* value) {
		lua_pushstring(context.mState, value);
		return 1;
	}
};

// floating numbers
template<typename T>
struct LuaContext::Pusher<T, typename std::enable_if<std::is_floating_point<T>::value>::type> {
	static int push(const LuaContext& context, T value) {
		lua_pushnumber(context.mState, value);
		return 1;
	}
};

// integers
template<typename T>
struct LuaContext::Pusher<T, typename std::enable_if<std::is_integral<T>::value>::type> {
	static int push(const LuaContext& context, T value) {
		lua_pushinteger(context.mState, value);
		return 1;
	}
};

// nil
template<>
struct LuaContext::Pusher<std::nullptr_t> {
	static int push(const LuaContext& context, std::nullptr_t value) {
		assert(value == nullptr);
		lua_pushnil(context.mState);
		return 1;
	}
};

// maps
template<typename TKey, typename TValue>
struct LuaContext::Pusher<std::map<TKey,TValue>> {
	static int push(const LuaContext& context, const std::map<TKey,TValue>& value) {
		lua_newtable(context.mState);

		for (auto i = value.begin(), e = value.end(); i != e; ++i) {
			Pusher<typename std::decay<TKey>::type>::push(context, i->first);
			Pusher<typename std::decay<TValue>::type>::push(context, i->second);
			lua_settable(context.mState, -3);
		}

		return 1;
	}
};

// unordered_maps
template<typename TKey, typename TValue>
struct LuaContext::Pusher<std::unordered_map<TKey,TValue>> {
	static int push(const LuaContext& context, const std::unordered_map<TKey,TValue>& value) {
		lua_newtable(context.mState);

		for (auto i = value.begin(), e = value.end(); i != e; ++i) {
			Pusher<typename std::decay<TKey>::type>::push(context, i->first);
			Pusher<typename std::decay<TValue>::type>::push(context, i->second);
			lua_settable(context.mState, -3);
		}

		return 1;
	}
};

// vectors
template<typename TType>
struct LuaContext::Pusher<std::vector<TType>> {
	static int push(const LuaContext& context, const std::vector<TType>& value) {
		lua_newtable(context.mState);

		for (unsigned int i = 0; i < value.size(); ++i) {
			lua_pushinteger(context.mState, i);
			Pusher<typename std::decay<TType>::type>::push(context, value[i]);
			lua_settable(context.mState, -3);
		}

		return 1;
	}
};

// unique_ptr
template<typename TType>
struct LuaContext::Pusher<std::unique_ptr<TType>> {
	static int push(const LuaContext& context, std::unique_ptr<TType> value) {
		return Pusher<std::shared_ptr<TType>>::push(context, std::move(value));
	}
};

// enum
#if !defined(__clang__) || __clang_major__ > 3 || (__clang_major__ == 3 && __clang_minor__ > 2)
template<typename TEnum>
struct LuaContext::Pusher<TEnum, typename std::enable_if<std::is_enum<TEnum>::value>::type> {
	static int push(const LuaContext& context, TEnum value) {
		typedef typename std::underlying_type<TEnum>::type	RealType;
		return Pusher<RealType>::push(context, static_cast<RealType>(value));
	}
};
#endif

// pushing a C function
/*template<typename FunctionType>
auto push(FunctionType fn) const
	-> typename std::enable_if<
					std::is_function<FunctionType>::value ||
					(std::is_pointer<FunctionType>::value && std::is_function<typename std::remove_pointer<FunctionType>::type>::value)
				,int>::type
{
	// utility structure
	typedef typename FnTupleWrapper<FunctionType>		TupleWrapper;

	// this is the function that will in fact receive the focus from lua
	const auto functionToPush = [](lua_State* state) -> int {
		// retreiving the parameters from the stack
		const auto me = static_cast<LuaContext*>(lua_touserdata(state, lua_upvalueindex(1)));
		const auto functionPtr = static_cast<FunctionType>(lua_touserdata(state, lua_upvalueindex(2)));
		
		// 
		static const int paramsCount = std::tuple_size<TupleWrapper::ParamsType>::value;
		if (lua_gettop(state) < paramsCount) {
			// if not, using lua_error to return an error
			luaL_where(state, 1);
			lua_pushstring(state, "This function requires at least ");
			lua_pushnumber(state, paramsCount);
			lua_pushstring(state, " parameter(s)");
			lua_concat(state, 4);

			// lua_error throws an exception when compiling as C++
			return lua_error(state);
		}

		// reading parameters
		TupleWrapper::ParamsType parameters;
		me->read(-paramsCount, &parameters);

		// calling function and returning
		auto result = TupleWrapper::call(functionPtr, std::move(parameters));
		return me->push(std::move(result));
	};

	// now that we have our function to push, we'll push it alongside with "this" and the function pointer
	lua_pushlightuserdata(mState, this);			// TODO: problem when move-constructing the lua context
	lua_pushlightuserdata(mState, fn);
	lua_pushcclose(mState, &functionToPush, 2);
	return 1;
}*/

// C function
template<typename TType>
struct LuaContext::Pusher<
	TType, typename std::enable_if<
										std::is_function<TType>::value ||
										(std::is_pointer<TType>::value && std::is_function<typename std::remove_pointer<TType>::type>::value)
									>::type
			>
{
	static int push(const LuaContext& context, TType value) {
		return context.pushFunction<TType>(value);
	}
};

// std::function
template<typename ReturnType, typename... ParamTypes>
struct LuaContext::Pusher<std::function<ReturnType (ParamTypes...)>> {
	static int push(const LuaContext& context, const std::function<ReturnType (ParamTypes...)>& value) {
		return context.pushFunction<ReturnType (ParamTypes...)>(value);
	}
};

// boost::variant
template<typename... TTypes>
struct LuaContext::Pusher<boost::variant<TTypes...>> {
	static int push(const LuaContext& context, const boost::variant<TTypes...>& value) {
		return value.apply_visitor(VariantWriter{context});
	}

private:
	struct VariantWriter : public boost::static_visitor<int> {
		template<typename TType>
		int operator()(TType value)
		{
			return Pusher<typename std::decay<TType>::type>::push(ctxt, value);
		}

		VariantWriter(const LuaContext& ctxt) : ctxt(ctxt) {}
		const LuaContext& ctxt;
	};
};

// tuple
template<typename... TTypes>
struct LuaContext::Pusher<std::tuple<TTypes...>> {
	static int push(const LuaContext& context, const std::tuple<TTypes...>& value) {
		return push2(context, value, std::integral_constant<int,0>{});
	}

private:
	template<int N>
	static int push2(const LuaContext& context, const std::tuple<TTypes...>& value, std::integral_constant<int,N>) {
		typedef typename std::tuple_element<N,std::tuple<TTypes...>>::type ElemType;
		const auto num = Pusher<typename std::decay<ElemType>::type>::push(context, std::get<N>(value));
		try {
			return num + push2(context, value, std::integral_constant<int,N+1>{});
		} catch(...) {
			lua_pop(context.mState, num);
			throw;
		}
	}
	
	static int push2(const LuaContext&, const std::tuple<TTypes...>&, std::integral_constant<int,sizeof...(TTypes)>) {
		return 0;
	}
};

/**************************************************/
/*                READ FUNCTIONS                  */
/**************************************************/
// reading null
template<>
struct LuaContext::Reader<std::nullptr_t>
{
	static bool test(const LuaContext& context, int index)
	{
		return lua_isnil(context.mState, index);
	}
	
	static auto read(const LuaContext& context, int index)
		-> std::nullptr_t
	{
		return nullptr;
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<std::nullptr_t>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> std::nullptr_t
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(std::nullptr_t)};
		return read(context, index);
	}
};

// integrals
template<typename TType>
struct LuaContext::Reader<
			TType,
			typename std::enable_if<std::is_integral<TType>::value>::type
		>
{
	static bool test(const LuaContext& context, int index)
	{
		return lua_isnumber(context.mState, index) && fmod(lua_tonumber(context.mState, index), 1.) == 0;
	}
	
	static auto read(const LuaContext& context, int index)
		-> TType
	{
		return lua_tointeger(context.mState, index);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<TType>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> TType
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(TType)};
		return read(context, index);
	}
};

// floating points
template<typename TType>
struct LuaContext::Reader<
			TType,
			typename std::enable_if<std::is_floating_point<TType>::value>::type
		>
{
	static bool test(const LuaContext& context, int index)
	{
		return lua_isnumber(context.mState, index) != 0;
	}
	
	static auto read(const LuaContext& context, int index)
		-> TType
	{
		return lua_tonumber(context.mState, index);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<TType>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> TType
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(TType)};
		return read(context, index);
	}
};

// boolean
template<>
struct LuaContext::Reader<bool>
{
	static bool test(const LuaContext& context, int index)
	{
		return lua_isboolean(context.mState, index);
	}
	
	static auto read(const LuaContext& context, int index)
		-> bool
	{
		return lua_toboolean(context.mState, index) != 0;
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<bool>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> bool
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(bool)};
		return read(context, index);
	}
};

// string
// lua_tostring returns a temporary pointer, but that's not a problem since we copy
//   the data into a std::string
template<>
struct LuaContext::Reader<std::string>
{
	static bool test(const LuaContext& context, int index)
	{
		return lua_isstring(context.mState, index) != 0;
	}
	
	static auto read(const LuaContext& context, int index)
		-> std::string
	{
		return lua_tostring(context.mState, index);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<std::string>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> std::string
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(std::string)};
		return read(context, index);
	}
};

// function
template<typename TRetValue, typename... TParameters>
struct LuaContext::Reader<std::function<TRetValue (TParameters...)>>
{
	typedef std::function<TRetValue (TParameters...)>
		Function;

	static bool test(const LuaContext& context, int index)
	{
		return lua_isfunction(context.mState, index) != 0;
	}
	
	static auto read(const LuaContext& context, int index)
		-> Function
	{
		auto beacon = std::make_shared<char>();

		lua_pushlightuserdata(context.mState, beacon.get());
		lua_pushvalue(context.mState, -2);
		lua_settable(context.mState, LUA_REGISTRYINDEX);

		return [&context,beacon](TParameters&&... params) -> TRetValue {
			lua_pushlightuserdata(context.mState, beacon.get());
			lua_gettable(context.mState, LUA_REGISTRYINDEX);
			return context.call<TRetValue>(std::make_tuple(std::forward<TParameters>(params)...));
		};
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<Function>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> Function
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(Function)};
		return read(context, index);
	}
};

// maps
template<typename TKey, typename TValue>
struct LuaContext::Reader<std::map<TKey,TValue>>
{
	typedef Reader<typename std::decay<TKey>::type>
		KeyReader;
	typedef Reader<typename std::decay<TValue>::type>
		ValueReader;

	static bool test(const LuaContext& context, int index)
	{
		return lua_istable(context.mState, index);
	}
	
	static auto read(const LuaContext& context, int index)
		-> std::map<TKey,TValue>
	{
		std::map<TKey,TValue> result;

		// we traverse the table at the top of the stack
		// TODO: handle exceptions
		lua_pushnil(context.mState);		// first key
		while (lua_next(context.mState, (index > 0) ? index : (index - 1)) != 0) {
			// now a key and its value are pushed on the stack
			try {
				auto key = KeyReader::testRead(context, -2);
				auto value = ValueReader::testRead(context, -1);

				if (!key.is_initialized() || !value.is_initialized()) {
					lua_pop(context.mState, 2);		// we remove the value and the key
					return {};
				}

				result.insert({ std::move(key.get()), std::move(value.get()) });
				lua_pop(context.mState, 1);		// we remove the value but keep the key for the next iteration

			} catch(...) {
				lua_pop(context.mState, 2);		// we remove the value and the key
				throw;
			}
		}

		return std::move(result);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<std::map<TKey,TValue>>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> std::map<TKey,TValue>
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(std::map<TKey,TValue>)};
		return read(context, index);
	}
};

// unordered_maps
template<typename TKey, typename TValue>
struct LuaContext::Reader<std::unordered_map<TKey,TValue>>
{
	typedef Reader<typename std::decay<TKey>::type>
		KeyReader;
	typedef Reader<typename std::decay<TValue>::type>
		ValueReader;

	static bool test(const LuaContext& context, int index)
	{
		return lua_istable(context.mState, index);
	}
	
	static auto read(const LuaContext& context, int index)
		-> std::unordered_map<TKey,TValue>
	{
		std::unordered_map<TKey,TValue> result;

		// we traverse the table at the top of the stack
		// TODO: handle exceptions
		lua_pushnil(context.mState);		// first key
		while (lua_next(context.mState, (index > 0) ? index : (index - 1)) != 0) {
			// now a key and its value are pushed on the stack
			try {
				auto key = KeyReader::testRead(context, -2);
				auto value = ValueReader::testRead(context, -1);

				if (!key.is_initialized() || !value.is_initialized()) {
					lua_pop(context.mState, 2);		// we remove the value and the key
					return {};
				}

				result.insert({ std::move(key.get()), std::move(value.get()) });
				lua_pop(context.mState, 1);		// we remove the value but keep the key for the next iteration

			} catch(...) {
				lua_pop(context.mState, 2);		// we remove the value and the key
				throw;
			}
		}

		return std::move(result);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<std::unordered_map<TKey,TValue>>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> std::unordered_map<TKey,TValue>
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(std::unordered_map<TKey,TValue>)};
		return read(context, index);
	}
};

// optional
template<typename TType>
struct LuaContext::Reader<boost::optional<TType>>
{
	typedef Reader<typename std::decay<TType>::type>
		SubReader;

	static bool test(const LuaContext& context, int index)
	{
		return lua_isnil(context.mState, index) || SubReader::test(context, index);
	}
	
	static auto read(const LuaContext& context, int index)
		-> boost::optional<TType>
	{
		return lua_isnil(context.mState, index) ? boost::optional<TType>{} : SubReader::read(context, index);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<boost::optional<TType>>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> boost::optional<TType>
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(boost::optional<TType>)};
		return read(context, index);
	}
};

// variant
template<typename... TTypes>
struct LuaContext::Reader<boost::variant<TTypes...>>
{
private:
	typedef boost::variant<TTypes...>
		Variant;
	
	template<typename TIterBegin, typename TIterEnd, typename = void>
	struct VariantReader {
		static Variant read(const LuaContext& ctxt, int index)
		{
			auto val = Reader<typename std::decay<typename boost::mpl::deref<TIterBegin>::type>::type>::testRead(ctxt, index);
			if (val.is_initialized())
				return Variant{std::move(val.get())};
			return VariantReader<typename boost::mpl::next<TIterBegin>::type, TIterEnd>::read(ctxt, index);
		}
	};

	template<typename TIterBegin, typename TIterEnd>
	struct VariantReader<TIterBegin, TIterEnd, typename std::enable_if<boost::mpl::distance<TIterBegin, TIterEnd>::type::value == 0>::type>
	{
		static Variant read(const LuaContext& ctxt, int index) {
			throw WrongTypeException(lua_typename(ctxt.mState, lua_type(ctxt.mState, index)), typeid(Variant));
		}
	};

public:
	static bool test(const LuaContext& context, int index)
	{
		return true;
	}
	
	static auto read(const LuaContext& context, int index)
		-> Variant
	{
		typedef typename boost::mpl::begin<typename Variant::types>::type		Begin;
		typedef typename boost::mpl::end<typename Variant::types>::type		End;

		return VariantReader<Begin, End>::read(context, index);
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<Variant>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> Variant
	{
		if (!test(context, index))
			throw WrongTypeException{lua_typename(context.mState, lua_type(context.mState, index)), typeid(Variant)};
		return read(context, index);
	}
};

// reading a tuple
template<>
struct LuaContext::Reader<std::tuple<>>
{
	static bool test(const LuaContext& context, int index)
	{
		return true;
	}
	
	static auto read(const LuaContext& context, int index)
		-> std::tuple<>
	{
		return {};
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<std::tuple<>>
	{
		return std::tuple<>{};
	}

	static auto readSafe(const LuaContext& context, int index)
		-> std::tuple<>
	{
		return {};
	}
};

template<typename TFirst, typename... TOthers>
struct LuaContext::Reader<std::tuple<TFirst, TOthers...>>
{
	typedef Reader<typename std::decay<TFirst>::type>
		TFirstReader;
	typedef Reader<std::tuple<TOthers...>>
		TOthersReader;

	static bool test(const LuaContext& context, int index)
	{
		return TFirstReader::test(context, index) && TOthersReader::test(context, index + 1);
	}
	
	static auto read(const LuaContext& context, int index)
		-> std::tuple<TFirst, TOthers...>
	{
		return std::tuple_cat(std::tuple<TFirst>{TFirstReader::read(context, index)}, TOthersReader::read(context, index + 1));
	}

	static auto testRead(const LuaContext& context, int index)
		-> boost::optional<std::tuple<TFirst, TOthers...>>
	{
		if (!test(context, index))
			return {};
		return read(context, index);
	}

	static auto readSafe(const LuaContext& context, int index)
		-> std::tuple<TFirst, TOthers...>
	{
		try {
			return std::tuple_cat(std::tuple<TFirst>{TFirstReader::readSafe(context, index)}, TOthersReader::readSafe(context, index + 1));

		} catch(...) {
			std::throw_with_nested(WrongTypeException{"unknown", typeid(std::tuple<TFirst,TOthers...>)});
		}
	}
};

#endif
